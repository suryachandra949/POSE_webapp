<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Power Optimised Software Envelope Models</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
          /* ===============================
           Base
           =============================== */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #EEEBE5;
        }
      
        /* ===============================
           Controls
           =============================== */
        .controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            position: relative;   /* REQUIRED */
            z-index: 10;          /* ABOVE Plotly */
        }
      
        /* DO NOT TOUCH z-index ON SELECT */
        select {
            min-width: 260px;
            padding: 4px 6px;
            font-size: 14px;
        }
      
        /* ===============================
           Plotly ‚Äî push DOWN instead
           =============================== */
        .js-plotly-plot {
            position: relative;
            z-index: 1;   /* ‚Üê THIS IS THE KEY */
        }

      
        /* ===============================
           Layout
           =============================== */
        #main {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            margin-top: 16px;
        }
      
        .block {
            display: flex;
            gap: 12px;
            width: 100%;
            max-width: 1100px;
        }
      
        .plot{
          flex: 1;
          min-height: 360px;
          height: 45vh;
          max-height: 520px;
          min-width: 0;

          /* IMPORTANT: don't style this like a card */
          background: transparent;
          border: none;
          border-radius: 0;
          padding: 0;
        }


        @media (max-width: 900px) {
            .block {
                flex-direction: column;
            }

            .results {
                width: 100%;
            }
        }

      
        /* ===============================
           Results panel
           =============================== */
        .results {
            width: 260px;
            padding: 12px;
            border: 1px solid #999;
            background: #F8F6F0;
            font-size: 14px;
            border-radius: 4px;
        }
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-body {
            position: relative;
        }
                /* ===============================
           Metrics tables styling
           =============================== */
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .metrics-table th,
        .metrics-table td {
            border: 1px solid #bbb;   /* ‚Üê grid lines */
            padding: 6px 8px;
            text-align: left;
            vertical-align: top;
        }

        .metrics-table thead th {
            background: #eee;
            font-weight: bold;
        }

        .metrics-table tbody tr:nth-child(even) {
            background: #f9f9f9;
        }

        /* Optional: derived table emphasis */
        .derived-table th {
            background: #e8f0ff;
        }

        /* Container for the options */
        .options {
            display: flex;
            gap: 20px;
            margin-top: 50px;
        }

        /* Each circle */
        .option {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            border-radius: 50%;       /* makes it a circle */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.2s;
            user-select: none;
        }

        /* Highlight selected circle */
        .option.selected {
            background-color: #4caf50;
            border-color: #4caf50;
            color: white;
        }

        /* Hover effect */
        .option:hover {
            border-color: #2196f3;
        }
        /* ===== Header ===== */
        .app-header {
          background: #6b4a3f;
          color: white;
          padding: 24px 32px;
        }

        .app-header h1 {
          margin: 0 0 6px;
          font-size: 28px;
        }

        .app-header p {
          margin: 0;
          opacity: 0.9;
          max-width: 900px;
        }

        /* ===== Filters Card ===== */
        .filters-card {
          background: #F8F6F0;
          border-bottom: 2px solid #d6cfc4;
          padding: 16px 24px 20px;
        }

        .filters-title {
          display: flex;
          align-items: center;
          gap: 10px;
          font-weight: 600;
          margin-bottom: 16px;
        }

        /* ===== Grid layout ===== */
        .filters-grid {
          display: grid;
          grid-template-columns: repeat(4, minmax(220px, 1fr));
          gap: 16px 24px;
        }

        .filter-item label {
          display: block;
          font-size: 13px;
          margin-bottom: 6px;
        }

        .filter-item input,
        .filter-item select {
          width: 100%;
          padding: 6px 8px;
          font-size: 14px;
        }

        /* Button cell */
        .button-item {
          display: flex;
          align-items: flex-end;
        }

        .button-item button {
          width: 100%;
          padding: 8px;
          font-weight: 600;
        }

        /* ===== Options row ===== */
        .options-row {
          display: flex;
          gap: 16px;
          margin-top: 20px;
        }

        /* ===== Responsive ===== */
        @media (max-width: 1100px) {
          .filters-grid {
            grid-template-columns: repeat(2, 1fr);
          }
        }

        @media (max-width: 600px) {
          .filters-grid {
            grid-template-columns: 1fr;
          }
        }

        .filters-title {
            cursor: pointer;
            user-select: none;
        }

        .toggle-icon {
          font-size: 18px;
          transition: transform 0.25s ease;
        }

        /* collapsed state */
        .filters-card.collapsed .filters-content {
          display: none;
        }

        .filters-card.collapsed .toggle-icon {
          transform: rotate(-90deg);
        }

        .plot-area {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 8px;
        }

        .plot-controls{
          display: flex;
          align-items: center;
          gap: 8px;
          font-size: 12.5px;

          flex-wrap: wrap;                 /* responsive */
          padding-bottom: 8px;
          border-bottom: 1px solid #d6cfc4; /* divider like reference UI */
        }

        .plot-controls label{
          margin-right: 4px;
          font-weight: 600;
          white-space: nowrap;
        }

        .plot-controls select{
          min-width: 130px;   /* wider = looks embedded */
          padding: 4px 6px;
          font-size: 13px;
        }

        .plot-card{
          background: #F8F6F0;
          border: 1.5px solid #999;
          border-radius: 6px;
          padding: 10px;
        }

        .clear-plot-btn{
          margin-left: auto;          /* push to right */
          width: 28px;
          height: 28px;
                
          display: flex;
          align-items: center;
          justify-content: center;
                
          font-size: 16px;
          line-height: 1;
                
          border: none;
          background: transparent;
          border-radius: 4px;
                
          cursor: pointer;
          color: #555;
        }
        
        .clear-plot-btn:hover{
          background: #e6e6e6;
          color: #000;
        }
        
        .clear-plot-btn:active{
          background: #dcdcdc;
        }

        .row-break{
          flex-basis: 100%;      /* take full row */
          width: 0;              /* don‚Äôt create extra space */
          height: 0;             /* invisible */
          padding: 0;
          margin: 0;
        }

        .hidden{ display:none; }

    </style>

</head>
<body>

<div class="app-header">
  <div class="header-left">
    <h1>Power Optimised Software Envelope Models</h1>
    <p>
      Interactive analysis of runtime‚Äìenergy tradeoffs using POSE models.
    </p>
  </div>
</div>

<div class="filters-card">
  <div class="filters-title" id="filtersToggle">
  <span class="toggle-icon" id="toggleIcon">‚öôÔ∏è</span>
  <span>Filters</span>
  </div>

  <div class="filters-content" id="filtersContent">
  <div class="filters-grid">

    <!-- Dataset -->
    <div class="filter-item">
      <label>Dataset</label>
      <select id="datasetSelect">
        <option value="MG">MG</option>
        <option value="FFT">FFT</option>
        <option value="LU">LU</option>
        <option value="CG">CG</option>
        <option value="BT">BT</option>
        <option value="EP">EP</option>
        <option value="SP">SP</option>
        <option value="HACC">HACC</option>
      </select>
    </div>



    <!-- Alpha -->
    <div class="filter-item">
      <label>Œ± (alpha)</label>
      <input id="alpha" type="number" step="any"
        value="0.00000004444444444" />
    </div>

    <!-- Beta -->
    <div class="filter-item">
      <label>Œ≤ (beta)</label>
      <input id="beta" type="number" step="any"
        value="0.00006363423285" />
    </div>

    <!-- n(EDP) -->
    <div class="filter-item">
      <label>n (EDP)</label>
      <input id="n" type="number" step="any"
         value="3" />
    </div>



    </div>

  </div>

  <!-- Options row -->
  <div class="options-row">
    <div class="option" data-value="EDD">EDD</div>
    <div class="option" data-value="EDS">EDS</div>
    <div class="option" data-value="EDP">EDP</div>
  </div>
</div>



<div id="main">

    <!-- ===== CASE 1 ===== -->
    <div class="block">
        <div class="plot-area">
          <div class="plot-card">
          <div class="plot-controls">
            
          <!-- ===== ROW 1 ===== -->
          <label>PMIN:</label>
          <select id="pminSelect1"></select>

          <label>PMAX:</label>
          <select id="pmaxSelect1"></select>

          <button
            class="clear-plot-btn"
            data-plot="plot1"
            type="button"
            title="Clear plot"
            aria-label="Clear plot">
            üßπ
          </button>

          <label style="margin-left:12px;">
            <input type="checkbox" id="plot1BatchToggle">
                    Batch view </label>

        
          <!-- force next row -->
          <span class="row-break"></span>
        
          <!-- ===== ROW 2 ===== -->
          <label>PLOT:</label>
          <select id="pointSelect1"></select>
        
          <label>COMPUTE:</label>
          <select id="computeSelect1"></select>

          </div>

          <div id="plot1" class="plot"></div>
          <div id="plot1BatchWrap" class="plot hidden">
          <div id="plot1_batch" style="width:100%;height:100%;"></div>
        </div>

        </div>
        </div>


        <div id="results1" class="results">
            <h3>POSE MODEL</h3>

            <div class="tabs">
                <button class="tab-btn active" data-tab="points1">Point Metrics</button>
                <button class="tab-btn" data-tab="derived1">Insights</button>
            </div>
            <div class="tab-body">
                <div class="tab-content active" id="tab-points1">
                  <div id="results-content1"></div>
                </div>

                <div class="tab-content" id="tab-derived1">
                  <div id="derived-content1"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ===== CASE 2 ===== -->
    <div class="block">
        <div class="plot-area">
          <div class="plot-card">
          <div class="plot-controls">

          <!-- ===== ROW 1 ===== -->
          <label>PMIN:</label>
          <select id="pminSelect2"></select>

          <label>PMAX:</label>
          <select id="pmaxSelect2"></select>

          <button
            class="clear-plot-btn"
            data-plot="plot2"
            type="button"
            title="Clear plot"
            aria-label="Clear plot">
            üßπ
          </button>

          <label style="margin-left:12px;">
            <input type="checkbox" id="plot2BatchToggle">
                Batch view
            </label>

        
          <!-- force next row -->
          <span class="row-break"></span>
        
          <!-- ===== ROW 2 ===== -->
          <label>PLOT:</label>
          <select id="pointSelect2"></select>
        
          <label>COMPUTE:</label>
          <select id="computeSelect2"></select>
          </div>

          <div id="plot2" class="plot"></div>
          <div id="plot2BatchWrap" class="plot hidden">
            <div id="plot2_batch" style="width:100%;height:100%;"></div>
          </div>

        </div>
        </div>

        <div id="results2" class="results">
            <h3>CACHE-AWARE POSE MODEL</h3>

            <div class="tabs">
                <button class="tab-btn active" data-tab="points2">Point Metrics</button>
                <button class="tab-btn" data-tab="derived2">Insights</button>
            </div>
            <div class="tab-body">
            <div class="tab-content active" id="tab-points2">
                <div id="results-content2"></div>
            </div>

            <div class="tab-content" id="tab-derived2">
                <div id="derived-content2"></div>
            </div>
            </div>
        </div>
    </div>

    <!-- ===== CASE 3 ===== -->
    <div class="block">
        <div class="plot-area">
          <div class="plot-card">
          <div class="plot-controls">

          <!-- ===== ROW 1 ===== -->
          <label>PMIN:</label>
          <select id="pminSelect3"></select>

          <label>PMAX:</label>
          <select id="pmaxSelect3"></select>

          <button
            class="clear-plot-btn"
            data-plot="plot3"
            type="button"
            title="Clear plot"
            aria-label="Clear plot">
            üßπ
          </button>
        
          <!-- force next row -->
          <span class="row-break"></span>
        
          <!-- ===== ROW 2 ===== -->
          <label>PLOT:</label>
          <select id="pointSelect3"></select>
        
          <label>COMPUTE:</label>
          <select id="computeSelect3"></select>
          </div>

          <div id="plot3" class="plot"></div>
        </div>
        </div>

        <div id="results3" class="results">
            <h3>Frequency and powercap analysis space(Brainstorming space)</h3>

            <div class="tabs">
                <button class="tab-btn active" data-tab="points3">Point Metrics</button>
                <button class="tab-btn" data-tab="derived3">Insights</button>
            </div>
            <div class="tab-body">
            <div class="tab-content active" id="tab-points3">
                <div id="results-content3"></div>
            </div>

            <div class="tab-content" id="tab-derived3">
                <div id="derived-content3"></div>
            </div>
            </div>
        </div>
    </div>

</div>



<script>
    // -------------------------------
    // Data from Flask
    // -------------------------------
//    const allPoints = {{ points | safe }};
//    const power = {{ power | safe }};

    let allPoints = {{ points | tojson }};
    let powerSets = {{ power_sets | tojson }};

    const datasetSelect = document.getElementById("datasetSelect");

    const plotUI = {
      plot1: {
        pointSelect: document.getElementById("pointSelect1"),
        computeSelect: document.getElementById("computeSelect1"),
        pminSelect: document.getElementById("pminSelect1"),
        pmaxSelect: document.getElementById("pmaxSelect1"),
      },
      plot2: {
        pointSelect: document.getElementById("pointSelect2"),
        computeSelect: document.getElementById("computeSelect2"),
        pminSelect: document.getElementById("pminSelect2"),
        pmaxSelect: document.getElementById("pmaxSelect2"),
      },
      plot3: {
        pointSelect: document.getElementById("pointSelect3"),
        computeSelect: document.getElementById("computeSelect3"),
        pminSelect: document.getElementById("pminSelect3"),
        pmaxSelect: document.getElementById("pmaxSelect3"),
      }
    };


    const plotState = {
      plot1: { labels: new Set(), token: 0 },
      plot2: { labels: new Set(), token: 0 },
      plot3: { labels: new Set(), token: 0 }
    };


    // -------------------------------
    // State tracking
    // -------------------------------
    const addedLabels = new Set();

    const plottedPoints = new Map(); // label -> point

    let plotContexts = [
      {
        plotId: "plot1",
        power: powerSets.case1,
        pmin: Math.min(...Object.values(powerSets.case1)),
        pmax: Math.max(...Object.values(powerSets.case1)),
        resultsId: "results-content1",
        derivedId: "derived-content1"
      },
      {
        plotId: "plot2",
        power: powerSets.case2,
        pmin: Math.min(...Object.values(powerSets.case2)),
        pmax: Math.max(...Object.values(powerSets.case2)),
        resultsId: "results-content2",
        derivedId: "derived-content2"
      },
      {
        plotId: "plot3",
        power: powerSets.case3,
        pmin: Math.min(...Object.values(powerSets.case3)),
        pmax: Math.max(...Object.values(powerSets.case3)),
        resultsId: "results-content3",
        derivedId: "derived-content3"
      }
    ];

    let selectedOption = null;  // store the currently selected circle
    

    // -------------------------------
    // Helpers
    // -------------------------------

    function resizeAllPlots() {
      ["plot1", "plot2", "plot3"].forEach(id => {
        const el = document.getElementById(id);
        if (el) Plotly.Plots.resize(el);
      });
    }

    window.addEventListener("resize", resizeAllPlots);


    function recomputeXMax(plotId) {
        const gd = document.getElementById(plotId);
        const xVals = gd.data.flatMap(t => t.x || []);
        return Math.max(...xVals, 1);
    }


    function updatePowerLines(plotId, xMax) {
      const gd = document.getElementById(plotId);
    
      gd.data.forEach((trace, i) => {
        if (trace.meta?.type === "power") {
          const slope = trace.meta.slope;
        
          Plotly.restyle(
            plotId,
            {
              x: [[0, xMax]],
              y: [[0, slope * xMax]]
            },
            [i]
          );
        }
      });
    }



//    function removeIntersectionTraces() {
//        const gd = document.getElementById("plot");
//        const indices = [];
//
//        gd.data.forEach((trace, i) => {
//            if (trace.meta && trace.meta.type === "intersection") {
//                indices.push(i);
//            }
//        });
//
//        if (indices.length > 0) {
//            Plotly.deleteTraces("plot", indices);
//        }
//
//        intersectionKeys.clear();
//    }
//
    function removeComputeTraces(plotId) {
        const gd = document.getElementById(plotId);
        const idx = [];
    
        gd.data.forEach((t, i) => {
            if (t.meta && (
                t.meta.type === "intersection" ||
                t.meta.type === "edd" ||
                t.meta.type === "edd_limit" ||
                t.meta.type === "D_line" ||
                t.meta.type === "C_line"
            )) {
                idx.push(i);
            }
        });
      
        if (idx.length) {
            Plotly.deleteTraces(plotId, idx);
        }
    }


    function labelPositionFromLine(line) {
        if (line === "pmax") return "top center";
        if (line === "pmin") return "bottom center";
        return "top right"; // fallback
    }

   
    function updateResultsPanel(containerId,metrics) {
        const rows = metrics.point_metrics;
    
        const tbody = rows.map(row => `
            <tr>
                <td>${row.label}</td>
                <td>${row.runtime.toFixed(5)}</td>
                <td>${row.energy.toFixed(5)}</td>
            </tr>
        `).join("");
          
        document.getElementById(containerId).innerHTML = `
            <table class="metrics-table">
                <thead>
                    <tr>
                        <th>Label</th>
                        <th>Runtime(s)</th>
                        <th>Energy(J)</th>
                    </tr>
                </thead>
                <tbody>
                    ${tbody}
                </tbody>
            </table>
        `;
    }

    function updateDerivedMetrics(containerId,derived) {
        const rows = derived.map(row => `
            <tr>
                <td>${row.name}</td>
                <td>${fmt(row.Absolute,row.value_unit)} ${row.value_unit}</td>
                <td>${Number(row.Relative).toFixed(3)}</td>
            </tr>
        `).join("");
          
        document.getElementById(containerId).innerHTML = `
            <table class="metrics-table derived-table">
                <thead>
                    <tr>
                        <th>Insight</th>
                        <th>Absolute</th>
                        <th>Relative</th>
                    </tr>
                </thead>
                <tbody>
                    ${rows}
                </tbody>
            </table>
        `;
    }

    function fmt(v, value_unit, digits = 3) {
        if (value_unit === "%" ){
          return v.toFixed(7);
        }

        else{
          return (typeof v === "number" && isFinite(v))
              ? v.toFixed(digits)
              : "‚Äî";
        }
    }

function isAnyBatchOn(){
  return !!(
    document.getElementById("plot1BatchToggle")?.checked ||
    document.getElementById("plot2BatchToggle")?.checked
  );
}

function setGlobalControlsEnabled(enabled){
  const disable = !enabled;

  document.getElementById("datasetSelect").disabled = disable;
  document.getElementById("alpha").disabled = disable;
  document.getElementById("beta").disabled  = disable;

  // metric circles
  document.querySelectorAll(".option").forEach(opt => {
    opt.style.pointerEvents = disable ? "none" : "auto";
    opt.style.opacity = disable ? "0.5" : "1";
  });
}

function setPlotControlsEnabled(plotId, enabled){
  const ui = plotUI[plotId];
  if (!ui) return;
  const disable = !enabled;

  ui.pminSelect.disabled = disable;
  ui.pmaxSelect.disabled = disable;
  ui.pointSelect.disabled = disable;
  ui.computeSelect.disabled = disable;

  document.querySelectorAll(`.clear-plot-btn[data-plot="${plotId}"]`).forEach(btn=>{
    btn.disabled = disable;
    btn.style.pointerEvents = disable ? "none" : "auto";
    btn.style.opacity = disable ? "0.5" : "1";
  });
}


function initBatchPlotFromSource(sourcePlotId, batchPlotId){
  const src = document.getElementById(sourcePlotId);
  if (!src?.data) return Promise.resolve();;

  // clone only power traces (so batch view looks like that plot's power setup)
  const powerTraces = src.data
    .filter(t => t.meta?.type === "power" && t.meta?.role !== "pmax")
    .map(t => JSON.parse(JSON.stringify(t))); // deep copy

  const layout = JSON.parse(JSON.stringify(src.layout || {}));
  //layout.title = layout.title || {};
  //layout.title.text = `${sourcePlotId.toUpperCase()} ‚Äî Batch view`;

  return Plotly.newPlot(batchPlotId, powerTraces, layout, {responsive:true, displaylogo: false, toImageButtonOptions: { format: "svg", filename: batchPlotId, scale: 1} });
}

function runBatchComputeFor(sourcePlotId, batchPlotId){
  if (!selectedOption) return;

  // use the source plot's current selected pmin/pmax
  const pm = getSelectedPminPmax(sourcePlotId);
  if (!pm) { alert("Select PMIN and PMAX first"); return; }

  const alpha = Number(document.getElementById("alpha").value);
  const beta  = Number(document.getElementById("beta").value);

  const n = Number(document.getElementById("n").value);
  if (!isFinite(n) || n <= 0) { alert("n must be a positive number"); return; }


  // batch points = points currently plotted on that plot (like plot3 logic)
  const labels = plotState[sourcePlotId]?.labels;
  if (!labels || labels.size === 0) return;

  // remove old compute traces from the batch plot only
  removeComputeTraces(batchPlotId);

  let firstC = true;
  let firstD = true;

  labels.forEach(lbl => {
    const p = plottedPoints.get(lbl);
    if (!p) return;

    fetch("/compute", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        point: p,
        pmin: pm.pmin,
        pmax: pm.pmax,
        alpha,
        beta,
        n,
        option: selectedOption
      })
    })
    .then(r => r.json())
    .then(data => {
      // add to the BATCH plot (not the source plot)
      Plotly.addTraces(batchPlotId, {
        x: data.D_line.runtime,
        y: data.D_line.energy,
        mode: "lines",
        name: "D-line" ,
        legendgroup: "D_LINE",
        showlegend: firstD,
        hovertemplate: `D-line<br>Point: ${lbl}<extra></extra>`,
        line: { color: "black", width: 1, dash: "dot" },
        meta: { type: "D_line" }
      });
      firstD = false;

      Plotly.addTraces(batchPlotId, {
        x: data.C_line.runtime,
        y: data.C_line.energy,
        mode: "lines",
        name: "C-line",
        legendgroup: "C_LINE",
        showlegend: firstC,
        hovertemplate: `C-line<br>Point: ${lbl}<extra></extra>`,
        line: { color: "#2B83BA", width: 1 },
        meta: { type: "C_line" }
      });
      firstC =false;

      // extend power lines on batch plot
      updatePowerLines(batchPlotId, recomputeXMax(batchPlotId));
    });
  });
}



    function runComputeForPlot(plotId, label, optionValue) {
  if (!label || !optionValue) return;

  const myToken = plotState[plotId].token;   // ‚úÖ capture token at start
  
  const pm = getSelectedPminPmax(plotId);
  if (!pm) { alert("Select PMIN and PMAX first"); return; }

  const alpha = Number(document.getElementById("alpha").value);
  if (!isFinite(alpha) || alpha <= 0) { alert("Œ± must be a positive number"); return; }

  const beta = Number(document.getElementById("beta").value);
  if (!isFinite(beta) || beta <= 0) { alert("Œ≤ must be a positive number"); return; }

  const n = Number(document.getElementById("n").value);
  if (!isFinite(n) || n <= 0) { alert("n must be a positive number"); return; }

  const ctx = plotContexts.find(c => c.plotId === plotId);
  if (!ctx) return;

  removeComputeTraces(plotId);

 // ‚úÖ plot3 special behavior: COMPUTE: ONLY points currently plotted on plot3
if (plotId === "plot3") {
  if (plotState.plot3.labels.size === 0) return;

  plotState.plot3.labels.forEach((lbl) => {
    const p = plottedPoints.get(lbl);
    if (!p) return;

    fetch("/compute", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        point: p,
        pmin: pm.pmin,
        pmax: pm.pmax,
        alpha,
        beta,
        n,
        option: optionValue
      })
    })
    .then(r => r.json())
    .then(data => {
      // ignore stale responses
      if (myToken !== plotState[plotId].token) return;

      Plotly.addTraces(plotId, {
        x: data.D_line.runtime,
        y: data.D_line.energy,
        mode: "lines",
        name: "max energy save",
        line: { color: "black", width: 1, dash: "dot" },
        meta: { type: "D_line" }
      });

      Plotly.addTraces(plotId, {
        x: data.C_line.runtime,
        y: data.C_line.energy,
        mode: "lines",
        name: "Contribution Bound",
        line: { color: "#2B83BA", width: 1 },
        meta: { type: "C_line" }
      });

      updatePowerLines(plotId, recomputeXMax(plotId));
    });
  });

  return;
}



  // ‚úÖ plot1/plot2 normal behavior: COMPUTE: selected label
  const p = plottedPoints.get(label);
  if (!p) return;

  fetch("/compute", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      point: p,
      pmin: pm.pmin,
      pmax: pm.pmax,
      alpha,
      beta,
      n,
      option: optionValue
    })
  })
  .then(r => r.json())
  .then(data => {
    if (myToken !== plotState[plotId].token) return;
    data.intersections.forEach(pt => {
      Plotly.addTraces(plotId, {
        x: [pt.x],
        y: [pt.y],
        mode: "markers+text",
        marker: { size: 6, symbol: "circle", color: "black" },
        text: [pt.label],
        textposition: labelPositionFromLine(pt.line),
        textfont: { size: 12, color: "black" },
        showlegend: false,
        meta: { type: "intersection" }
      });
    });

    Plotly.addTraces(plotId, {
      x: data.edd_curve_limit.runtime,
      y: data.edd_curve_limit.energy,
      mode: "lines",
      name: "EDD limit constraint",
      line: { color: "orange", width: 1, dash: "dash" },
      meta: { type: "edd_limit" }
    });

    Plotly.addTraces(plotId, {
      x: data.edd_curve.runtime,
      y: data.edd_curve.energy,
      mode: "lines",
      name: "EDD optimisation constraint",
      line: { color: "orange", width: 1 },
      meta: { type: "edd" }
    });

    Plotly.addTraces(plotId, {
      x: data.D_line.runtime,
      y: data.D_line.energy,
      mode: "lines",
      name: "max energy save",
      line: { color: "black", width: 1, dash: "dot" },
      meta: { type: "D_line" }
    });

    Plotly.addTraces(plotId, {
      x: data.C_line.runtime,
      y: data.C_line.energy,
      mode: "lines",
      name: "Contribution Bound",
      line: { color: "#2B83BA", width: 1 },
      meta: { type: "C_line" }
    });

    updatePowerLines(plotId, recomputeXMax(plotId));
    updateResultsPanel(ctx.resultsId, data.metrics);
    updateDerivedMetrics(ctx.derivedId, data.metrics.derived_metrics);
  });
}

function addBatchPoints(sourcePlotId, batchPlotId){
  const labels = plotState[sourcePlotId]?.labels;
  if (!labels || labels.size === 0) return;

  labels.forEach(lbl => {
    const p = plottedPoints.get(lbl);
    if (!p) return;

    Plotly.addTraces(batchPlotId, {
      x: [p.runtime],
      y: [p.energy],
      mode: "markers",
      name: lbl,                // point label
      marker: { size: 6 },
      meta: { type: "point", label: lbl }
    });
  });
}

function attachPminPmaxHandlers() {
  Object.entries(plotUI).forEach(([plotId, ui]) => {

    // Use onchange (not addEventListener) so repeated calls won't double-bind
    ui.pminSelect.onchange = () => {
      const name = ui.pminSelect.value;
      if (name) setPowerLineFromDropdown(plotId, "pmin", name);

      const label = ui.computeSelect.value;
      if (label && selectedOption) runComputeForPlot(plotId, label, selectedOption);
    };

    ui.pmaxSelect.onchange = () => {
      const name = ui.pmaxSelect.value;
      if (name) setPowerLineFromDropdown(plotId, "pmax", name);

      const label = ui.computeSelect.value;
      if (label && selectedOption) runComputeForPlot(plotId, label, selectedOption);
    };

  });
}



function attachComputeSelectHandlers() {
  Object.entries(plotUI).forEach(([plotId, ui]) => {
    ui.computeSelect.onchange = () => {
      const label = ui.computeSelect.value;
      if (!label || !selectedOption) return;
      runComputeForPlot(plotId, label, selectedOption);
    };
  });
}




    document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.addEventListener("click", () => {

        // find the parent results panel
        const results = btn.closest(".results");

        // deactivate tabs ONLY in this panel
        results.querySelectorAll(".tab-btn").forEach(b =>
            b.classList.remove("active")
        );
        results.querySelectorAll(".tab-content").forEach(c =>
            c.classList.remove("active")
        );

        // activate selected
        btn.classList.add("active");
        results
            .querySelector("#tab-" + btn.dataset.tab)
            .classList.add("active");
        });
    });

    function getSelectedPminPmax(plotId) {
      const ctx = plotContexts.find(c => c.plotId === plotId);
      const ui = plotUI[plotId];
      if (!ctx || !ui) return null;

      const pminKey = ui.pminSelect.value;
      const pmaxKey = ui.pmaxSelect.value;
      if (!pminKey || !pmaxKey) return null;

      const pmin = ctx.power[pminKey];
      const pmax = ctx.power[pmaxKey];
      if (!isFinite(pmin) || !isFinite(pmax)) return null;

      return { pmin, pmax, pminKey, pmaxKey };
    }

// ========================
// Initialize dataset
// ========================
function loadDataset(name){
    fetch(`/load_dataset/${name}`)
      .then(res=>{
          if(!res.ok) throw new Error("HTTP "+res.status);
          return res.json();
      })
      .then(data=>{
          allPoints = data.points;
          powerSets = data.power_sets;

          resetPointDropdown(allPoints);
          resetAllPlots();
          initPlots();
          populatePminPmax("plot1");
          populatePminPmax("plot2");
          populatePminPmax("plot3");


          attachPminPmaxHandlers();
          attachAddPointHandlers();
          attachComputeSelectHandlers();

      })
      .catch(err=>{
          console.error("Failed to load dataset:", name, err);
          alert("Failed to load dataset: "+name);
      });
}

function populatePminPmax(plotId) {
  const ctx = plotContexts.find(c => c.plotId === plotId);
  const ui  = plotUI[plotId];
  if (!ctx || !ui) return;

  const slopes = ctx.power;       // {name: slope}
  const roles  = ctx.roles || {}; // {name: "pmin"/"pmax"/"other"}

  ui.pminSelect.innerHTML = `<option value="">-- pmin --</option>`;
  ui.pmaxSelect.innerHTML = `<option value="">-- pmax --</option>`;

  Object.keys(slopes).forEach(name => {
    const role = roles[name];
    if (role === "pmin") ui.pminSelect.appendChild(new Option(name, name));
    if (role === "pmax") ui.pmaxSelect.appendChild(new Option(name, name));
  });

  // ‚úÖ auto-select FIRST available (not only when exactly 1)
  if (!ui.pminSelect.value && ui.pminSelect.options.length > 1) ui.pminSelect.selectedIndex = 1;
  if (!ui.pmaxSelect.value && ui.pmaxSelect.options.length > 1) ui.pmaxSelect.selectedIndex = 1;

  // ‚úÖ immediately apply to replace placeholder lines
  if (ui.pminSelect.value) setPowerLineFromDropdown(plotId, "pmin", ui.pminSelect.value);
  if (ui.pmaxSelect.value) setPowerLineFromDropdown(plotId, "pmax", ui.pmaxSelect.value);
}



datasetSelect.addEventListener("change", ()=>loadDataset(datasetSelect.value));

document.addEventListener("DOMContentLoaded", () => {
    resetPointDropdown(allPoints);
    resetAllPlots();
    initPlots();

    populatePminPmax("plot1");
    populatePminPmax("plot2");
    populatePminPmax("plot3");

    attachPminPmaxHandlers();
    attachAddPointHandlers();
    attachComputeSelectHandlers();
    attachClearButtons();

    // Set default alpha and beta values
    document.getElementById("alpha").value = "0.00000004444444444";
    document.getElementById("beta").value = "0.00006363423285";

    const options = document.querySelectorAll(".option");

    options.forEach(opt => {
      opt.addEventListener("click", () => {
        options.forEach(o => o.classList.remove("selected"));
        opt.classList.add("selected");

        selectedOption = opt.dataset.value;
        console.log("Selected metric:", selectedOption);

        Object.entries(plotUI).forEach(([plotId, ui]) => {
          const label = ui.computeSelect.value;
          if (!label) return;
          runComputeForPlot(plotId, label, selectedOption);
        });
      });
    });

    const defaultOption = options[0];          // choose first circle by default
    defaultOption.classList.add("selected");   // highlight
    selectedOption = defaultOption.dataset.value;


    // =========================
  // ‚úÖ Batch toggles (MUST be OUTSIDE the loop above)
  // =========================
  const t1 = document.getElementById("plot1BatchToggle");
  const t2 = document.getElementById("plot2BatchToggle");

  const w1 = document.getElementById("plot1BatchWrap");
  const w2 = document.getElementById("plot2BatchWrap");

function refreshLocks(){
  const b1 = document.getElementById("plot1BatchToggle")?.checked;
  const b2 = document.getElementById("plot2BatchToggle")?.checked;

  // ‚úÖ global is locked if ANY batch is on
  setGlobalControlsEnabled(!(b1 || b2));

  // ‚úÖ per-plot: only lock the plot that is in batch mode
  setPlotControlsEnabled("plot1", !b1);
  setPlotControlsEnabled("plot2", !b2);
}


  async function enterBatch(sourcePlotId){
  refreshLocks();

  if (sourcePlotId === "plot1"){
    // ‚úÖ swap plots in-place
    document.getElementById("plot1").classList.add("hidden");
    w1.classList.remove("hidden");

    await initBatchPlotFromSource("plot1", "plot1_batch");

    removeBatchPointTraces("plot1_batch");
    addBatchPoints("plot1", "plot1_batch");
    runBatchComputeFor("plot1", "plot1_batch");

    // optional: force resize
    Plotly.Plots.resize(document.getElementById("plot1_batch"));
  }

  if (sourcePlotId === "plot2"){
    document.getElementById("plot2").classList.add("hidden");
    w2.classList.remove("hidden");

    await initBatchPlotFromSource("plot2", "plot2_batch");

    removeBatchPointTraces("plot2_batch");
    addBatchPoints("plot2", "plot2_batch"); 
    runBatchComputeFor("plot2", "plot2_batch");

    Plotly.Plots.resize(document.getElementById("plot2_batch"));
  }
}

function exitBatch(sourcePlotId){
  if (sourcePlotId === "plot1"){
    // ‚úÖ swap back
    w1.classList.add("hidden");
    document.getElementById("plot1").classList.remove("hidden");

    Plotly.purge("plot1_batch");
    Plotly.Plots.resize(document.getElementById("plot1"));
  }

  if (sourcePlotId === "plot2"){
    w2.classList.add("hidden");
    document.getElementById("plot2").classList.remove("hidden");

    Plotly.purge("plot2_batch");
    Plotly.Plots.resize(document.getElementById("plot2"));
  }

  refreshLocks();
}


  t1.onchange = () => (t1.checked ? enterBatch("plot1") : exitBatch("plot1"));
  t2.onchange = () => (t2.checked ? enterBatch("plot2") : exitBatch("plot2"));

  refreshLocks();

    const filtersToggle = document.getElementById("filtersToggle");
    const filtersCard = document.querySelector(".filters-card");
    const toggleIcon = document.getElementById("toggleIcon");

    filtersToggle.addEventListener("click", () => {
        const collapsed = filtersCard.classList.toggle("collapsed");

        // Change icon
        toggleIcon.textContent = collapsed ? "‚ò∞" : "‚öôÔ∏è";

        // Resize plots after toggle
        setTimeout(() => {
          ["plot1", "plot2", "plot3"].forEach(id => {
            const el = document.getElementById(id);
            if (el) Plotly.Plots.resize(el);
          });
  }, 150);
});

});

function initPlots(){
  plotContexts = [
    {
      plotId: "plot1",
      power: powerSets.case1.slopes,
      roles: powerSets.case1.roles,
      resultsId: "results-content1",
      derivedId: "derived-content1"
    },
    {
      plotId: "plot2",
      power: powerSets.case2.slopes,
      roles: powerSets.case2.roles,
      resultsId: "results-content2",
      derivedId: "derived-content2"
    },
    {
      plotId: "plot3",
      power: powerSets.case3.slopes,
      roles: powerSets.case3.roles,
      resultsId: "results-content3",
      derivedId: "derived-content3"
    }
  ];

  plotContexts.forEach(ctx => {
    const slopes = ctx.power;
    const roles  = ctx.roles || {};

    // 1) Plot ONLY "other" lines at startup
    const otherEntries = Object.entries(slopes)
      .filter(([name]) => (roles[name] || "other") === "other")
      .sort((a, b) => a[1] - b[1]);

    const otherTraces = otherEntries.map(([name, slope]) => ({
      x: [0, 1],
      y: [0, slope],
      mode: "lines",
      name: name,
      line: { width: 2 },                 // no forced colors
      meta: { type: "power", role: "other", slope, name }
    }));

    // 2) Add placeholder traces for PMIN + PMAX (these will be replaced)
    const pminTrace = {
      x: [0, 1],
      y: [0, 1],
      mode: "lines",
      name: "PMIN",
      line: { width: 2, color: "green" },   // ‚úÖ green
      meta: { type: "power", role: "pmin", slope: 1, name: "PMIN" }
    };

    const pmaxTrace = {
      x: [0, 1],
      y: [0, 1],
      mode: "lines",
      name: "PMAX",
      line: { width: 2, color: "red" },     // ‚úÖ red
      meta: { type: "power", role: "pmax", slope: 1, name: "PMAX" }
    };


    Plotly.newPlot(
      ctx.plotId,
      [...otherTraces, pminTrace, pmaxTrace],
      {
        autosize: true,
        paper_bgcolor: "#F8F6F0",
        plot_bgcolor: "#fafafa",
        xaxis: {
          title: "Runtime",
          showgrid: true,
          gridcolor: "#ddd",
          zeroline: false,
          showline: true,
          linewidth: 2,
          linecolor: "#000",
          mirror: true
        },
        yaxis: {
          title: "Energy",
          showgrid: true,
          gridcolor: "#ddd",
          zeroline: false,
          showline: true,
          linewidth: 2,
          linecolor: "#000",
          mirror: true
        },
        margin: { l: 60, r: 30, t: 40, b: 50 },
        legend: {
          bgcolor: "rgba(255,255,255,0.9)",
          bordercolor: "#aaa",
          borderwidth: 1
        }
      },
      { responsive: true,
        displaylogo: false,
        toImageButtonOptions: {
        format: "svg",          // ‚úÖ SVG export
        filename: ctx.plotId,   // plot1 / plot2 / plot3
        scale: 1
       }
      }
    );
  });
}

function findPowerTraceIndexByRole(plotId, role){
  const gd = document.getElementById(plotId);
  if (!gd?.data) return -1;
  return gd.data.findIndex(t => t.meta?.type === "power" && t.meta?.role === role);
}

function setPowerLineFromDropdown(plotId, role, chosenName){
  const ctx = plotContexts.find(c => c.plotId === plotId);
  if (!ctx) return;

  const slope = ctx.power[chosenName];
  if (!isFinite(slope)) return;

  const gd = document.getElementById(plotId);
  const idx = findPowerTraceIndexByRole(plotId, role);
  if (!gd || idx === -1) return;

  const oldMeta = gd.data[idx].meta || {};
  const newMeta = { ...oldMeta, type: "power", role, slope, name: chosenName };

  Plotly.restyle(plotId, {
    x: [[0, 1]],
    y: [[0, slope]],
    name: [chosenName],
    meta: [newMeta]
  }, [idx]);

  // extend lines correctly using the NEW meta.slope
  updatePowerLines(plotId, recomputeXMax(plotId));
}


function resetPointDropdown(points) {
  // reset plot dropdowns
  Object.values(plotUI).forEach(ui => {
    ui.pointSelect.innerHTML = `<option value="">-- select --</option>`;
    points.forEach((p, i) => ui.pointSelect.appendChild(new Option(p.label, i)));

    ui.computeSelect.innerHTML = `<option value="">-- plotted points --</option>`;
  });

  addedLabels.clear();
  plottedPoints.clear();
}

function attachAddPointHandlers() {
  Object.entries(plotUI).forEach(([plotId, ui]) => {
    ui.pointSelect.onchange = () => {
      const idx = ui.pointSelect.value;
      if (idx === "") return;

      const p = allPoints[idx];
      if (!p) return;

      // ‚úÖ prevent duplicates on the SAME plot
      if (plotState[plotId].labels.has(p.label)) {
        ui.pointSelect.value = "";   // reset dropdown
        return;
      }

      // track globally (so plot3 / batch can use it)
      if (!addedLabels.has(p.label)) {
        addedLabels.add(p.label);
        plottedPoints.set(p.label, p);
      }


      // PLOT: to THIS plot only
      Plotly.addTraces(plotId, {
        x: [p.runtime],
        y: [p.energy],
        mode: "markers",
        name: p.label,
        legendgroup: "points",
        showlegend: true,
        marker: { size: 6 }
      });

      plotState[plotId].labels.add(p.label);

      updatePowerLines(plotId, recomputeXMax(plotId));

      // add to THIS plot‚Äôs compute dropdown
      const exists = Array.from(ui.computeSelect.options).some(o => o.value === p.label);
      if (!exists) ui.computeSelect.appendChild(new Option(p.label, p.label));

      // optionally auto-select last added point for compute
      ui.computeSelect.value = "";

      ui.pointSelect.value = "";
    };
  });
}



function resetAllPlots() {
    ["plot1", "plot2", "plot3"].forEach(id => {
        Plotly.purge(id);
    });
}




// Add change listeners to alpha and beta inputs
["alpha", "beta","n"].forEach(id => {
  const input = document.getElementById(id);
  
  input.addEventListener("change", () => {
    const value = Number(input.value);
    
    if (!isFinite(value) || value <= 0) {
      alert(`${id} must be a positive number`);
      // ‚úÖ reset correct default per parameter
      if (id === "alpha") {
        input.value = "0.00000004444444444";
      } else if (id === "beta") {
        input.value = "0.00006363423285";
      } else if (id === "n") {
        input.value = "3";               // ‚úÖ default n
      }

      return;
    }

    // If needed, you can trigger a recompute here automatically
    Object.entries(plotUI).forEach(([plotId, ui]) => {
      const label = ui.computeSelect.value;
      if (label && selectedOption) runComputeForPlot(plotId, label, selectedOption);
    });

    console.log(`${id} changed to`, value);
    
  });
});

function getPowerTraceIndices(plotId){
  const gd = document.getElementById(plotId);
  if (!gd || !gd.data) return [];
  const keep = [];
  gd.data.forEach((t, i) => {
    if (t.meta?.type === "power") keep.push(i);
  });
  return keep;
}

function clearPlot(plotId){
  const ctx = plotContexts.find(c => c.plotId === plotId);
  if (!ctx) return;

  // ‚úÖ invalidate any in-flight compute for this plot
  plotState[plotId].token++;
  plotState[plotId].labels.clear();

  const gd = document.getElementById(plotId);
  if (!gd || !gd.data) return;

  // delete everything except power lines
  const keep = new Set(getPowerTraceIndices(plotId));
  const toDelete = gd.data.map((_, i) => i).filter(i => !keep.has(i));
  if (toDelete.length) Plotly.deleteTraces(plotId, toDelete);

  // also remove compute traces (safe if already removed)
  removeComputeTraces(plotId);

  // reset power line extents back to baseline
  updatePowerLines(plotId, 1);

  // reset this plot's dropdowns
  if (plotUI[plotId]) {
    plotUI[plotId].computeSelect.innerHTML = `<option value="">-- plotted points --</option>`;
    plotUI[plotId].pointSelect.value = "";
     plotUI[plotId].computeSelect.value = ""; // ‚úÖ clear selection too
  }

  // clear this plot‚Äôs result panel (optional but recommended)
  document.getElementById(ctx.resultsId).innerHTML = "";
  document.getElementById(ctx.derivedId).innerHTML = "";
}

function attachClearButtons(){
  document.querySelectorAll(".clear-plot-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      clearPlot(btn.dataset.plot);
    });
  });
}

function removeBatchPointTraces(batchPlotId){
  const gd = document.getElementById(batchPlotId);
  if (!gd?.data) return;

  const idx = [];
  gd.data.forEach((t,i) => {
    if (t.meta?.type === "point") idx.push(i);
  });
  if (idx.length) Plotly.deleteTraces(batchPlotId, idx);
}





</script>

</body>
</html>
